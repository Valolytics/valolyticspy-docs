<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>valolyticspy.models.match API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>valolyticspy.models.match</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
sys.path.append(&#34;&#34;)

from valolyticspy.dtos.riot.enums import MatchRegion
from typing import List, Union, Dict, Optional
from datetime import datetime
from enum import Enum
from valolyticspy.services.dto_loader import ValorantDTO
from valolyticspy.dtos.valorant_api.map import Map
from valolyticspy.dtos.valorant_api.agent import Agent, Ability
from valolyticspy.dtos.valorant_api.weapon import Weapon
from valolyticspy.dtos.valorant_api.gear import Gear
from valolyticspy.dtos.valorant_api.ceremony import Ceremony
from valolyticspy.dtos.valorant_api.competitive_tier import Tier
from valolyticspy.dtos.valorant_api.player_card import PlayerCard
from valolyticspy.dtos.valorant_api.player_title import PlayerTitle
from valolyticspy.services.helper.map_from_mapId import get_map_from_mapId
from valolyticspy.services.helper.competitive_tier_from_tier import get_competitive_tier_from_tier
from valolyticspy.services.helper.ceremony_from_roundCeremony import get_ceremony_from_roundCeremony
from valolyticspy.dtos.riot.match import MatchInfoDto, AbilityCastsDto, TeamDto, PlayerDto, FinishingDamageDto, PlayerLocationsDto, KillDto, DamageDto, EconomyDto, PlayerRoundStatsDto, RoundResultDto, MatchDto, PlayerStatsDto as NormalPlayerStatsDto
from valolyticspy.dtos.valolytics.playerstats import SideStatsDto, PlayerStatsDto

from enum import Enum

class Side(Enum):
    &#34;&#34;&#34;
    Enum representing the sides in a match.

    Attributes:
        ATTACK (str): Represents the attacking side.
        DEFENSE (str): Represents the defending side.
    &#34;&#34;&#34;
    ATTACK = &#34;Attack&#34;
    DEFENSE = &#34;Defense&#34;

from enum import Enum

class TeamId(Enum):
    &#34;&#34;&#34;
    Enum representing the team ID.

    Attributes:
        RED (str): The team ID for the red team.
        BLUE (str): The team ID for the blue team.
    &#34;&#34;&#34;
    RED = &#34;Red&#34;
    BLUE = &#34;Blue&#34;

class MatchInfoModel(MatchInfoDto):
    &#34;&#34;&#34;
    Represents a model for match information.

    Attributes:
        gameStart (datetime): The start time of the game.
        map (Map): The map on which the game was played.
    &#34;&#34;&#34;

    gameStart: datetime
    map: Map

    @classmethod
    def from_dto(cls, dto: MatchInfoDto) -&gt; &#34;MatchInfoModel&#34;:
        &#34;&#34;&#34;
        Creates a MatchInfoModel instance from a MatchInfoDto instance.

        Args:
            dto (MatchInfoDto): The MatchInfoDto instance to convert.

        Returns:
            MatchInfoModel: The converted MatchInfoModel instance.
        &#34;&#34;&#34;
        return cls(
            **dto.model_dump(),
            gameStart=datetime.fromtimestamp(dto.gameStartMillis // 1000),
            map=get_map_from_mapId(dto.mapId)
        )

class AbilityCastsModel(AbilityCastsDto):
    &#34;&#34;&#34;A model representing the ability casts in a match.&#34;&#34;&#34;

    def __getitem__(self, key:str) -&gt; int:
        &#34;&#34;&#34;Get the number of casts for a specific ability.

        Args:
            key (str): The key representing the ability.

        Returns:
            int: The number of casts for the specified ability.
        &#34;&#34;&#34;
        return getattr(self, f&#34;{key.lower()}Casts&#34;)

class TeamModel(TeamDto):
    &#34;&#34;&#34;
    Represents a team model.

    Attributes:
        teamId (int): The ID of the team.
    &#34;&#34;&#34;

    @classmethod
    def from_dto(cls, dto:TeamDto) -&gt; &#34;TeamModel&#34;:
        &#34;&#34;&#34;
        Creates a TeamModel instance from a TeamDto instance.

        Args:
            dto (TeamDto): The TeamDto instance.

        Returns:
            TeamModel: The created TeamModel instance.
        &#34;&#34;&#34;
        return cls(**dto.model_dump())

    def side(self, roundNum:int) -&gt; Side:
        &#34;&#34;&#34;
        Determines the side of the team based on the round number.

        Args:
            roundNum (int): The round number.

        Returns:
            Side: The side of the team.
        &#34;&#34;&#34;
        if(roundNum &lt; 12 or (roundNum &gt;= 24 and roundNum % 2 == 0)):
            return Side.ATTACK if self.teamId == TeamId.RED.value else Side.DEFENSE
        else:
            return Side.DEFENSE if self.teamId == TeamId.RED.value else Side.ATTACK

class PlayerModel(PlayerDto):
    &#34;&#34;&#34;
    Represents a player in the game.

    Attributes:
        agent (Optional[Agent]): The agent chosen by the player.
        competitiveTier (Tier): The competitive tier of the player.
        playerCard (PlayerCard): The player&#39;s selected card.
        playerTitle (Optional[PlayerTitle]): The player&#39;s selected title.
        team (Optional[TeamModel]): The team the player belongs to.
        stats (Optional[Union[SideStatsDto, NormalPlayerStatsDto]]): The player&#39;s statistics.

    Methods:
        from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; PlayerModel:
            Creates a PlayerModel instance from a PlayerDto object.
        __hash__(self) -&gt; int:
            Returns the hash value of the PlayerModel instance.
    &#34;&#34;&#34;

    agent: Optional[Agent] = None
    competitiveTier: Tier
    playerCard: PlayerCard
    playerTitle: Optional[PlayerTitle] = None
    team: Optional[TeamModel] = None
    stats: Optional[Union[SideStatsDto, NormalPlayerStatsDto]] = None

    @classmethod
    def from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; &#34;PlayerModel&#34;:
        &#34;&#34;&#34;
        Converts a PlayerDto object to a PlayerModel object.

        Args:
            dto (PlayerDto): The PlayerDto object to convert.
            team (TeamModel): The TeamModel object to associate with the player.
            playerStats (PlayerStatsDto, optional): The PlayerStatsDto object to use for player stats. Defaults to None.

        Returns:
            PlayerModel: The converted PlayerModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;competitiveTier&#34;)
        dumped_model.pop(&#34;playerCard&#34;)
        dumped_model.pop(&#34;playerTitle&#34;)
        dumped_model.pop(&#34;stats&#34;)
        return cls(
            **dumped_model,
            agent=ValorantDTO.AGENTS[dto.characterId.lower()] if dto.characterId != None else None,
            competitiveTier=get_competitive_tier_from_tier(dto.competitiveTier),
            playerCard=ValorantDTO.PLAYER_CARDS[dto.playerCard],
            playerTitle=ValorantDTO.PLAYER_TITLES[dto.playerTitle] if dto.playerTitle != &#34;&#34; else None,
            team=team,
            stats=playerStats.side if playerStats != None else dto.stats
        )

    def __hash__(self) -&gt; int:
            &#34;&#34;&#34;
            Returns the hash value of the object based on its &#39;puuid&#39; attribute.

            Returns:
                int: The hash value of the object.
            &#34;&#34;&#34;
            return hash(self.puuid)

class FinishingDamageModel(FinishingDamageDto):
    &#34;&#34;&#34;
    Represents a model for finishing damage in a match.

    Attributes:
        damageItem (Optional[Union[Ability, Weapon, str]]): The damage item associated with the finishing damage.
    &#34;&#34;&#34;

    damageItem: Optional[Union[Ability, Weapon, str]] = None

    @classmethod
    def from_dto(cls, dto: FinishingDamageDto, damageItem: Union[Ability, Weapon, str]) -&gt; &#34;FinishingDamageModel&#34;:
        &#34;&#34;&#34;
        Creates a `FinishingDamageModel` instance from a `FinishingDamageDto` object.

        Args:
            cls: The class object.
            dto: The `FinishingDamageDto` object containing the data.
            damageItem: The damage item associated with the finishing damage.

        Returns:
            A new instance of `FinishingDamageModel` with the data from the `FinishingDamageDto` object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;damageItem&#34;)
        return cls(
            **dumped_model,
            damageItem=damageItem
        )

class KillModel(KillDto):
    &#34;&#34;&#34;
    Represents a kill event in a match.

    Attributes:
        killer (PlayerModel): The player who performed the kill.
        victim (PlayerModel): The player who was killed.
        assistants (List[PlayerModel]): The players who assisted in the kill.
        playerLocations (Dict[str, PlayerLocationsDto]): The locations of the players involved in the kill.
        finishingDamage (FinishingDamageModel): The finishing damage information for the kill.
    &#34;&#34;&#34;

    killer: PlayerModel
    victim: PlayerModel
    assistants: List[PlayerModel]
    playerLocations: Dict[str, PlayerLocationsDto]
    finishingDamage: FinishingDamageModel

    @classmethod
    def from_dto(cls, dto: KillDto, killer: PlayerModel, victim: PlayerModel, assistants: List[PlayerModel], finishingDamage: FinishingDamageModel) -&gt; &#34;KillModel&#34;:
        &#34;&#34;&#34;
        Creates a KillModel instance from a KillDto and related objects.

        Args:
            dto (KillDto): The KillDto object containing the kill information.
            killer (PlayerModel): The player who performed the kill.
            victim (PlayerModel): The player who was killed.
            assistants (List[PlayerModel]): The players who assisted in the kill.
            finishingDamage (FinishingDamageModel): The finishing damage information for the kill.

        Returns:
            KillModel: The created KillModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;killer&#34;)
        dumped_model.pop(&#34;victim&#34;)
        dumped_model.pop(&#34;assistants&#34;)
        dumped_model.pop(&#34;playerLocations&#34;)
        dumped_model.pop(&#34;finishingDamage&#34;)
        return cls(
            **dumped_model,
            killer=killer,
            victim=victim,
            assistants=assistants,
            playerLocations={player_location.puuid: player_location for player_location in dto.playerLocations},
            finishingDamage=finishingDamage
        )

class DamageModel(DamageDto):
    &#34;&#34;&#34;
    Represents a damage model in the game.
    
    Attributes:
        receiver (PlayerModel): The player who received the damage.
    &#34;&#34;&#34;
    receiver: PlayerModel

    @classmethod
    def from_dto(cls, dto: DamageDto, receiver: PlayerModel) -&gt; &#34;DamageModel&#34;:
        &#34;&#34;&#34;
        Creates a DamageModel instance from a DamageDto object and a receiver PlayerModel.
        
        Args:
            dto (DamageDto): The DamageDto object containing the damage information.
            receiver (PlayerModel): The PlayerModel object representing the receiver of the damage.
        
        Returns:
            DamageModel: The created DamageModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;receiver&#34;)
        return cls(
            **dumped_model,
            receiver=receiver
        )

class EconomyModel(EconomyDto):
    &#34;&#34;&#34;
    Represents an economy model in the game.
    
    Attributes:
        weapon (Optional[Weapon]): The weapon equipped by the player. Defaults to None.
        armor (Optional[Gear]): The armor equipped by the player. Defaults to None.
    &#34;&#34;&#34;
    weapon: Optional[Weapon] = None
    armor: Optional[Gear] = None

    @classmethod
    def from_dto(cls, dto: EconomyDto) -&gt; &#34;EconomyModel&#34;:
        &#34;&#34;&#34;
        Creates an instance of EconomyModel from an EconomyDto object.
        
        Args:
            dto (EconomyDto): The EconomyDto object to create the EconomyModel from.
        
        Returns:
            EconomyModel: The created EconomyModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;weapon&#34;)
        dumped_model.pop(&#34;armor&#34;)
        return cls(
            **dumped_model,
            weapon=ValorantDTO.WEAPONS[dto.weapon.lower()] if dto.weapon != &#34;&#34; else None,
            armor=ValorantDTO.GEAR[dto.armor.lower()] if dto.armor != &#34;&#34; else None
        )

class PlayerRoundStatsModel(PlayerRoundStatsDto):
    &#34;&#34;&#34;
    Represents the model for player round statistics.

    Attributes:
        player (PlayerModel): The player associated with the round statistics.
        kills (List[KillModel]): The list of kills made by the player.
        damage (List[DamageModel]): The list of damage inflicted by the player.
        economy (EconomyModel): The economy information of the player.

    Methods:
        from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; PlayerRoundStatsModel:
            Creates a new instance of PlayerRoundStatsModel from the provided DTO and related models.
    &#34;&#34;&#34;
    player: PlayerModel
    kills: List[KillModel]
    damage: List[DamageModel]
    economy: EconomyModel

    @classmethod
    def from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; &#34;PlayerRoundStatsModel&#34;:
        &#34;&#34;&#34;
        Converts a PlayerRoundStatsDto object to a PlayerRoundStatsModel object.

        Args:
            dto (PlayerRoundStatsDto): The PlayerRoundStatsDto object to convert.
            player (PlayerModel): The PlayerModel object associated with the stats.
            kills (List[KillModel]): A list of KillModel objects representing the kills made by the player.
            damage (List[DamageModel]): A list of DamageModel objects representing the damage dealt by the player.

        Returns:
            PlayerRoundStatsModel: The converted PlayerRoundStatsModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;kills&#34;)
        dumped_model.pop(&#34;damage&#34;)
        dumped_model.pop(&#34;economy&#34;)
        return cls(
            **dumped_model,
            player=player,
            kills=kills,
            damage=damage,
            economy=EconomyModel.from_dto(dto.economy)
        )

class RoundResultModel(RoundResultDto):
    &#34;&#34;&#34;
    Represents a round result in a match.

    Attributes:
        roundCeremony (Optional[Ceremony]): The ceremony associated with the round.
        winningTeam (TeamModel): The winning team of the round.
        bombPlanter (Optional[PlayerModel]): The player who planted the bomb.
        isBombPlantAfterRoundEnd (Optional[bool]): Whether the bomb was planted after the round ended.
        bombDefuser (Optional[PlayerModel]): The player who defused the bomb.
        plantPlayerLocations (Optional[Dict[str, PlayerLocationsDto]]): The locations of players who planted the bomb.
        defusePlayerLocations (Optional[Dict[str, PlayerLocationsDto]]): The locations of players who defused the bomb.
        playerStats (Dict[str, PlayerRoundStatsModel]): The statistics of players in the round.
        kills (List[KillModel]): The kills that occurred in the round.
    &#34;&#34;&#34;

    roundCeremony: Optional[Ceremony] = None
    winningTeam: TeamModel
    bombPlanter: Optional[PlayerModel] = None
    isBombPlantAfterRoundEnd: Optional[bool] = None
    bombDefuser: Optional[PlayerModel] = None
    plantPlayerLocations: Optional[Dict[str, PlayerLocationsDto]] = None
    defusePlayerLocations: Optional[Dict[str, PlayerLocationsDto]] = None
    playerStats: Dict[str, PlayerRoundStatsModel]
    kills: List[KillModel]

    @classmethod
    def from_dto(cls, dto: RoundResultDto, winningTeam: TeamModel, bombPlanter: PlayerModel, bombDefuser: PlayerModel, playerStats: Dict[str, PlayerRoundStatsModel], kills: List[KillModel]) -&gt; &#34;RoundResultModel&#34;:
        &#34;&#34;&#34;
        Converts a RoundResultDto object into a RoundResultModel object.

        Args:
            dto (RoundResultDto): The RoundResultDto object to convert.
            winningTeam (TeamModel): The winning team of the round.
            bombPlanter (PlayerModel): The player who planted the bomb.
            bombDefuser (PlayerModel): The player who defused the bomb.
            playerStats (Dict[str, PlayerRoundStatsModel]): A dictionary of player round statistics.
            kills (List[KillModel]): A list of kill events.

        Returns:
            RoundResultModel: The converted RoundResultModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;roundCeremony&#34;)
        dumped_model.pop(&#34;winningTeam&#34;)
        dumped_model.pop(&#34;bombPlanter&#34;)
        dumped_model.pop(&#34;bombDefuser&#34;)
        dumped_model.pop(&#34;plantPlayerLocations&#34;)
        dumped_model.pop(&#34;defusePlayerLocations&#34;)
        dumped_model.pop(&#34;playerStats&#34;)

        match dto.roundResult:
            case &#34;Eliminated&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; kills[-1].timeSinceRoundStartMillis else False
            case &#34;Round timer expired&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; 100*1000 else False
            case _: isBombPlantAfterRoundEnd = None

        return cls(
            **dumped_model,
            roundCeremony=get_ceremony_from_roundCeremony(dto.roundCeremony),
            winningTeam=winningTeam,
            bombPlanter=bombPlanter,
            isBombPlantAfterRoundEnd=isBombPlantAfterRoundEnd,
            bombDefuser=bombDefuser,
            plantPlayerLocations={player_location.puuid: player_location for player_location in dto.plantPlayerLocations} if dto.plantPlayerLocations != None else None,
            defusePlayerLocations={player_location.puuid: player_location for player_location in dto.defusePlayerLocations} if dto.defusePlayerLocations != None else None,
            playerStats=playerStats,
            kills=kills
        )

class MatchModel(MatchDto):
    &#34;&#34;&#34;
    Represents a match in the ValolyticsPy application.

    Attributes:
        matchInfo (MatchInfoModel): Information about the match.
        teams (Dict[str, TeamModel]): A dictionary of teams in the match, where the key is the team ID and the value is the TeamModel object.
        players (Dict[str, PlayerModel]): A dictionary of players in the match, where the key is the player&#39;s PUUID and the value is the PlayerModel object.
        observers (Optional[Dict[str, PlayerModel]]): A dictionary of observers in the match, where the key is the observer&#39;s PUUID and the value is the PlayerModel object. Defaults to None.
        roundResults (List[RoundResultModel]): A list of round results in the match.
        raw_dto (Optional[MatchDto]): The raw MatchDto object used to initialize the MatchModel. Defaults to None.

    Methods:
        __init__(self, data: MatchDto, valolytics_client=None, region: MatchRegion=None): Initializes a MatchModel object.
        get_puuids_from_team(self, team: TeamModel) -&gt; List[str]: Returns a list of PUUIDs from a specific team.
        get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel: Returns the team that contains any of the given PUUIDs.
    &#34;&#34;&#34;
    matchInfo: MatchInfoModel
    teams: Dict[str, TeamModel]
    players: Dict[str, PlayerModel]
    observers: Optional[Dict[str, PlayerModel]] = None
    roundResults: List[RoundResultModel]
    raw_dto: Optional[MatchDto] = None

    def __init__(self, data: MatchDto, valolytics_client=None, region: MatchRegion=None):
        &#34;&#34;&#34;
        Initializes a MatchModel object.

        Args:
            data (MatchDto): The MatchDto object containing the match data.
            valolytics_client (optional): The Valolytics client object used to fetch player stats. Defaults to None.
            region (optional): The region of the match. Defaults to None.
        &#34;&#34;&#34;
        teams: Dict[str, TeamModel] = {team.teamId: TeamModel.from_dto(team) for team in data.teams}
        players: Dict[str, PlayerModel] = {}
        observers: Dict[str, PlayerModel] = {}
        if valolytics_client != None and region != None:
            playerStats: Dict[str, PlayerStatsDto] = valolytics_client.get_playerstats_by_match_id(data.matchInfo.matchId, region)
        for player in data.players:
            if player.teamId != &#34;Neutral&#34;:
                if valolytics_client != None and region != None:
                    players[player.puuid] = PlayerModel.from_dto(player, teams[player.teamId], playerStats[player.puuid])
                else:
                    players[player.puuid] = PlayerModel.from_dto(player, teams[player.teamId])
            else:
                observers[player.puuid] = PlayerModel.from_dto(player, None)

        ordered_kills: List[KillModel] = []
        rounds: List[RoundResultModel] = []
        for round in data.roundResults:
            winningTeam: TeamModel = teams[round.winningTeam] if round.winningTeam != None else None
            bombPlanter: PlayerModel = players[round.bombPlanter] if round.bombPlanter != None else None
            bombDefuser: PlayerModel = players[round.bombDefuser] if round.bombDefuser != None else None
            
            player_stats: Dict[str, PlayerRoundStatsModel] = {}
            for player in round.playerStats:

                kills: List[KillModel] = []
                for kill in player.kills:
                    killer = players[kill.killer]
                    victim = players[kill.victim]
                    assistants: List[PlayerModel] = []

                    for assist in kill.assistants:
                        assistants.append(players[assist])

                    damageItem: Union[Weapon, Ability, str] = None

                    if (kill.finishingDamage.damageType == &#34;Weapon&#34;):
                        try:
                            damageItem = ValorantDTO.WEAPONS[kill.finishingDamage.damageItem.lower()]
                        except:
                            damageItem = kill.finishingDamage.damageItem
                    elif (kill.finishingDamage.damageType == &#34;Ability&#34;):
                        damageItemStr = kill.finishingDamage.damageItem if kill.finishingDamage.damageItem != &#34;GrenadeAbility&#34; else &#34;Grenade&#34;
                        
                        for ability in players[kill.killer].agent.abilities:
                            if ability.slot == damageItemStr:
                                damageItem = ability
                                break
                    elif (kill.finishingDamage.damageType == &#34;&#34;):
                        kill.finishingDamage.damageType = &#34;Bomb&#34;
                        damageItem = &#34;&#34;

                    kills.append(KillModel.from_dto(kill, killer, victim, assistants, FinishingDamageModel.from_dto(kill.finishingDamage, damageItem)))
                    ordered_kills.extend(kills)

                damages: List[DamageModel] = []
                for damage in player.damage:
                    damages.append(DamageModel.from_dto(damage, players[damage.receiver]))

                player_stats[player.puuid] = PlayerRoundStatsModel.from_dto(player, players[player.puuid], kills, damages)

            ordered_kills.sort(key=lambda kill: kill.timeSinceRoundStartMillis)
            rounds.append(RoundResultModel.from_dto(round, winningTeam, bombPlanter, bombDefuser, player_stats, ordered_kills))
            players

        super().__init__(
            matchInfo=MatchInfoModel.from_dto(data.matchInfo),
            teams=teams,
            players=players,
            coaches=data.coaches,
            roundResults=rounds
        )
        self.observers = observers,
        self.raw_dto = data

    def get_puuids_from_team(self, team: TeamModel) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns a list of PUUIDs from a specific team.

        Args:
            team (TeamModel): The team to get the PUUIDs from.

        Returns:
            List[str]: A list of PUUIDs from the specified team.
        &#34;&#34;&#34;
        puuids: List[str] = []
        for player in self.players.values():
            if player.team == team:
                puuids.append(player.puuid)
        return puuids

    def get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel:
        &#34;&#34;&#34;
        Returns the team that contains any of the given PUUIDs.

        Args:
            puuids (List[str]): The list of PUUIDs to check.

        Returns:
            TeamModel: The team that contains any of the given PUUIDs.
        &#34;&#34;&#34;
        any_in_team_red = any(element in set(self.get_puuids_from_team(self.teams[TeamId.RED.value])) for element in puuids)
        any_in_team_blue = any(element in set(self.get_puuids_from_team(self.teams[TeamId.BLUE.value])) for element in puuids)

        if any_in_team_red and not any_in_team_blue:
            return self.teams[TeamId.RED.value]
        elif any_in_team_blue and not any_in_team_red:
            return self.teams[TeamId.BLUE.value]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="valolyticspy.models.match.AbilityCastsModel"><code class="flex name class">
<span>class <span class="ident">AbilityCastsModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A model representing the ability casts in a match.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbilityCastsModel(AbilityCastsDto):
    &#34;&#34;&#34;A model representing the ability casts in a match.&#34;&#34;&#34;

    def __getitem__(self, key:str) -&gt; int:
        &#34;&#34;&#34;Get the number of casts for a specific ability.

        Args:
            key (str): The key representing the ability.

        Returns:
            int: The number of casts for the specified ability.
        &#34;&#34;&#34;
        return getattr(self, f&#34;{key.lower()}Casts&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.AbilityCastsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.AbilityCastsDto">AbilityCastsDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.AbilityCastsModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.AbilityCastsModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.AbilityCastsModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.DamageModel"><code class="flex name class">
<span>class <span class="ident">DamageModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a damage model in the game.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>receiver</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who received the damage.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DamageModel(DamageDto):
    &#34;&#34;&#34;
    Represents a damage model in the game.
    
    Attributes:
        receiver (PlayerModel): The player who received the damage.
    &#34;&#34;&#34;
    receiver: PlayerModel

    @classmethod
    def from_dto(cls, dto: DamageDto, receiver: PlayerModel) -&gt; &#34;DamageModel&#34;:
        &#34;&#34;&#34;
        Creates a DamageModel instance from a DamageDto object and a receiver PlayerModel.
        
        Args:
            dto (DamageDto): The DamageDto object containing the damage information.
            receiver (PlayerModel): The PlayerModel object representing the receiver of the damage.
        
        Returns:
            DamageModel: The created DamageModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;receiver&#34;)
        return cls(
            **dumped_model,
            receiver=receiver
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.DamageDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.DamageDto">DamageDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.DamageModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.DamageModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.DamageModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.DamageModel.receiver"><code class="name">var <span class="ident">receiver</span> : <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.DamageModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.DamageDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.DamageDto">DamageDto</a>, receiver: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>) ‑> <a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a DamageModel instance from a DamageDto object and a receiver PlayerModel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>DamageDto</code></dt>
<dd>The DamageDto object containing the damage information.</dd>
<dt><strong><code>receiver</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The PlayerModel object representing the receiver of the damage.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a></code></dt>
<dd>The created DamageModel instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: DamageDto, receiver: PlayerModel) -&gt; &#34;DamageModel&#34;:
    &#34;&#34;&#34;
    Creates a DamageModel instance from a DamageDto object and a receiver PlayerModel.
    
    Args:
        dto (DamageDto): The DamageDto object containing the damage information.
        receiver (PlayerModel): The PlayerModel object representing the receiver of the damage.
    
    Returns:
        DamageModel: The created DamageModel instance.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;receiver&#34;)
    return cls(
        **dumped_model,
        receiver=receiver
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.EconomyModel"><code class="flex name class">
<span>class <span class="ident">EconomyModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an economy model in the game.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>weapon</code></strong> :&ensp;<code>Optional[Weapon]</code></dt>
<dd>The weapon equipped by the player. Defaults to None.</dd>
<dt><strong><code>armor</code></strong> :&ensp;<code>Optional[Gear]</code></dt>
<dd>The armor equipped by the player. Defaults to None.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EconomyModel(EconomyDto):
    &#34;&#34;&#34;
    Represents an economy model in the game.
    
    Attributes:
        weapon (Optional[Weapon]): The weapon equipped by the player. Defaults to None.
        armor (Optional[Gear]): The armor equipped by the player. Defaults to None.
    &#34;&#34;&#34;
    weapon: Optional[Weapon] = None
    armor: Optional[Gear] = None

    @classmethod
    def from_dto(cls, dto: EconomyDto) -&gt; &#34;EconomyModel&#34;:
        &#34;&#34;&#34;
        Creates an instance of EconomyModel from an EconomyDto object.
        
        Args:
            dto (EconomyDto): The EconomyDto object to create the EconomyModel from.
        
        Returns:
            EconomyModel: The created EconomyModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;weapon&#34;)
        dumped_model.pop(&#34;armor&#34;)
        return cls(
            **dumped_model,
            weapon=ValorantDTO.WEAPONS[dto.weapon.lower()] if dto.weapon != &#34;&#34; else None,
            armor=ValorantDTO.GEAR[dto.armor.lower()] if dto.armor != &#34;&#34; else None
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.EconomyDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.EconomyDto">EconomyDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.EconomyModel.armor"><code class="name">var <span class="ident">armor</span> : Optional[<a title="valolyticspy.dtos.valorant_api.gear.Gear" href="../dtos/valorant_api/gear.html#valolyticspy.dtos.valorant_api.gear.Gear">Gear</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.EconomyModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.EconomyModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.EconomyModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.EconomyModel.weapon"><code class="name">var <span class="ident">weapon</span> : Optional[<a title="valolyticspy.dtos.valorant_api.weapon.Weapon" href="../dtos/valorant_api/weapon.html#valolyticspy.dtos.valorant_api.weapon.Weapon">Weapon</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.EconomyModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.EconomyDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.EconomyDto">EconomyDto</a>) ‑> <a title="valolyticspy.models.match.EconomyModel" href="#valolyticspy.models.match.EconomyModel">EconomyModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of EconomyModel from an EconomyDto object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>EconomyDto</code></dt>
<dd>The EconomyDto object to create the EconomyModel from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.EconomyModel" href="#valolyticspy.models.match.EconomyModel">EconomyModel</a></code></dt>
<dd>The created EconomyModel instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: EconomyDto) -&gt; &#34;EconomyModel&#34;:
    &#34;&#34;&#34;
    Creates an instance of EconomyModel from an EconomyDto object.
    
    Args:
        dto (EconomyDto): The EconomyDto object to create the EconomyModel from.
    
    Returns:
        EconomyModel: The created EconomyModel instance.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;weapon&#34;)
    dumped_model.pop(&#34;armor&#34;)
    return cls(
        **dumped_model,
        weapon=ValorantDTO.WEAPONS[dto.weapon.lower()] if dto.weapon != &#34;&#34; else None,
        armor=ValorantDTO.GEAR[dto.armor.lower()] if dto.armor != &#34;&#34; else None
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.FinishingDamageModel"><code class="flex name class">
<span>class <span class="ident">FinishingDamageModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a model for finishing damage in a match.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>damageItem</code></strong> :&ensp;<code>Optional[Union[Ability, Weapon, str]]</code></dt>
<dd>The damage item associated with the finishing damage.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinishingDamageModel(FinishingDamageDto):
    &#34;&#34;&#34;
    Represents a model for finishing damage in a match.

    Attributes:
        damageItem (Optional[Union[Ability, Weapon, str]]): The damage item associated with the finishing damage.
    &#34;&#34;&#34;

    damageItem: Optional[Union[Ability, Weapon, str]] = None

    @classmethod
    def from_dto(cls, dto: FinishingDamageDto, damageItem: Union[Ability, Weapon, str]) -&gt; &#34;FinishingDamageModel&#34;:
        &#34;&#34;&#34;
        Creates a `FinishingDamageModel` instance from a `FinishingDamageDto` object.

        Args:
            cls: The class object.
            dto: The `FinishingDamageDto` object containing the data.
            damageItem: The damage item associated with the finishing damage.

        Returns:
            A new instance of `FinishingDamageModel` with the data from the `FinishingDamageDto` object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;damageItem&#34;)
        return cls(
            **dumped_model,
            damageItem=damageItem
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.FinishingDamageDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.FinishingDamageDto">FinishingDamageDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.FinishingDamageModel.damageItem"><code class="name">var <span class="ident">damageItem</span> : Union[<a title="valolyticspy.dtos.valorant_api.agent.Ability" href="../dtos/valorant_api/agent.html#valolyticspy.dtos.valorant_api.agent.Ability">Ability</a>, <a title="valolyticspy.dtos.valorant_api.weapon.Weapon" href="../dtos/valorant_api/weapon.html#valolyticspy.dtos.valorant_api.weapon.Weapon">Weapon</a>, str, ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.FinishingDamageModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.FinishingDamageModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.FinishingDamageModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.FinishingDamageModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.FinishingDamageDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.FinishingDamageDto">FinishingDamageDto</a>, damageItem: Union[<a title="valolyticspy.dtos.valorant_api.agent.Ability" href="../dtos/valorant_api/agent.html#valolyticspy.dtos.valorant_api.agent.Ability">Ability</a>, <a title="valolyticspy.dtos.valorant_api.weapon.Weapon" href="../dtos/valorant_api/weapon.html#valolyticspy.dtos.valorant_api.weapon.Weapon">Weapon</a>, str]) ‑> <a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code> instance from a <code>FinishingDamageDto</code> object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cls</code></strong></dt>
<dd>The class object.</dd>
<dt><strong><code>dto</code></strong></dt>
<dd>The <code>FinishingDamageDto</code> object containing the data.</dd>
<dt><strong><code>damageItem</code></strong></dt>
<dd>The damage item associated with the finishing damage.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new instance of <code><a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code> with the data from the <code>FinishingDamageDto</code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: FinishingDamageDto, damageItem: Union[Ability, Weapon, str]) -&gt; &#34;FinishingDamageModel&#34;:
    &#34;&#34;&#34;
    Creates a `FinishingDamageModel` instance from a `FinishingDamageDto` object.

    Args:
        cls: The class object.
        dto: The `FinishingDamageDto` object containing the data.
        damageItem: The damage item associated with the finishing damage.

    Returns:
        A new instance of `FinishingDamageModel` with the data from the `FinishingDamageDto` object.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;damageItem&#34;)
    return cls(
        **dumped_model,
        damageItem=damageItem
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.KillModel"><code class="flex name class">
<span>class <span class="ident">KillModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a kill event in a match.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>killer</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who performed the kill.</dd>
<dt><strong><code>victim</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who was killed.</dd>
<dt><strong><code>assistants</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>The players who assisted in the kill.</dd>
<dt><strong><code>playerLocations</code></strong> :&ensp;<code>Dict[str, PlayerLocationsDto]</code></dt>
<dd>The locations of the players involved in the kill.</dd>
<dt><strong><code>finishingDamage</code></strong> :&ensp;<code><a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code></dt>
<dd>The finishing damage information for the kill.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KillModel(KillDto):
    &#34;&#34;&#34;
    Represents a kill event in a match.

    Attributes:
        killer (PlayerModel): The player who performed the kill.
        victim (PlayerModel): The player who was killed.
        assistants (List[PlayerModel]): The players who assisted in the kill.
        playerLocations (Dict[str, PlayerLocationsDto]): The locations of the players involved in the kill.
        finishingDamage (FinishingDamageModel): The finishing damage information for the kill.
    &#34;&#34;&#34;

    killer: PlayerModel
    victim: PlayerModel
    assistants: List[PlayerModel]
    playerLocations: Dict[str, PlayerLocationsDto]
    finishingDamage: FinishingDamageModel

    @classmethod
    def from_dto(cls, dto: KillDto, killer: PlayerModel, victim: PlayerModel, assistants: List[PlayerModel], finishingDamage: FinishingDamageModel) -&gt; &#34;KillModel&#34;:
        &#34;&#34;&#34;
        Creates a KillModel instance from a KillDto and related objects.

        Args:
            dto (KillDto): The KillDto object containing the kill information.
            killer (PlayerModel): The player who performed the kill.
            victim (PlayerModel): The player who was killed.
            assistants (List[PlayerModel]): The players who assisted in the kill.
            finishingDamage (FinishingDamageModel): The finishing damage information for the kill.

        Returns:
            KillModel: The created KillModel instance.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;killer&#34;)
        dumped_model.pop(&#34;victim&#34;)
        dumped_model.pop(&#34;assistants&#34;)
        dumped_model.pop(&#34;playerLocations&#34;)
        dumped_model.pop(&#34;finishingDamage&#34;)
        return cls(
            **dumped_model,
            killer=killer,
            victim=victim,
            assistants=assistants,
            playerLocations={player_location.puuid: player_location for player_location in dto.playerLocations},
            finishingDamage=finishingDamage
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.KillDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.KillDto">KillDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.KillModel.assistants"><code class="name">var <span class="ident">assistants</span> : List[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.finishingDamage"><code class="name">var <span class="ident">finishingDamage</span> : <a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.killer"><code class="name">var <span class="ident">killer</span> : <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.playerLocations"><code class="name">var <span class="ident">playerLocations</span> : Dict[str, <a title="valolyticspy.dtos.riot.match.PlayerLocationsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerLocationsDto">PlayerLocationsDto</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.KillModel.victim"><code class="name">var <span class="ident">victim</span> : <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.KillModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.KillDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.KillDto">KillDto</a>, killer: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>, victim: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>, assistants: List[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>], finishingDamage: <a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a>) ‑> <a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a KillModel instance from a KillDto and related objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>KillDto</code></dt>
<dd>The KillDto object containing the kill information.</dd>
<dt><strong><code>killer</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who performed the kill.</dd>
<dt><strong><code>victim</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who was killed.</dd>
<dt><strong><code>assistants</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>The players who assisted in the kill.</dd>
<dt><strong><code>finishingDamage</code></strong> :&ensp;<code><a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code></dt>
<dd>The finishing damage information for the kill.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a></code></dt>
<dd>The created KillModel instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: KillDto, killer: PlayerModel, victim: PlayerModel, assistants: List[PlayerModel], finishingDamage: FinishingDamageModel) -&gt; &#34;KillModel&#34;:
    &#34;&#34;&#34;
    Creates a KillModel instance from a KillDto and related objects.

    Args:
        dto (KillDto): The KillDto object containing the kill information.
        killer (PlayerModel): The player who performed the kill.
        victim (PlayerModel): The player who was killed.
        assistants (List[PlayerModel]): The players who assisted in the kill.
        finishingDamage (FinishingDamageModel): The finishing damage information for the kill.

    Returns:
        KillModel: The created KillModel instance.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;killer&#34;)
    dumped_model.pop(&#34;victim&#34;)
    dumped_model.pop(&#34;assistants&#34;)
    dumped_model.pop(&#34;playerLocations&#34;)
    dumped_model.pop(&#34;finishingDamage&#34;)
    return cls(
        **dumped_model,
        killer=killer,
        victim=victim,
        assistants=assistants,
        playerLocations={player_location.puuid: player_location for player_location in dto.playerLocations},
        finishingDamage=finishingDamage
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.MatchInfoModel"><code class="flex name class">
<span>class <span class="ident">MatchInfoModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a model for match information.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>gameStart</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The start time of the game.</dd>
<dt><strong><code>map</code></strong> :&ensp;<code>Map</code></dt>
<dd>The map on which the game was played.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchInfoModel(MatchInfoDto):
    &#34;&#34;&#34;
    Represents a model for match information.

    Attributes:
        gameStart (datetime): The start time of the game.
        map (Map): The map on which the game was played.
    &#34;&#34;&#34;

    gameStart: datetime
    map: Map

    @classmethod
    def from_dto(cls, dto: MatchInfoDto) -&gt; &#34;MatchInfoModel&#34;:
        &#34;&#34;&#34;
        Creates a MatchInfoModel instance from a MatchInfoDto instance.

        Args:
            dto (MatchInfoDto): The MatchInfoDto instance to convert.

        Returns:
            MatchInfoModel: The converted MatchInfoModel instance.
        &#34;&#34;&#34;
        return cls(
            **dto.model_dump(),
            gameStart=datetime.fromtimestamp(dto.gameStartMillis // 1000),
            map=get_map_from_mapId(dto.mapId)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.MatchInfoDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.MatchInfoDto">MatchInfoDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.MatchInfoModel.gameStart"><code class="name">var <span class="ident">gameStart</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchInfoModel.map"><code class="name">var <span class="ident">map</span> : <a title="valolyticspy.dtos.valorant_api.map.Map" href="../dtos/valorant_api/map.html#valolyticspy.dtos.valorant_api.map.Map">Map</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchInfoModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchInfoModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchInfoModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.MatchInfoModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.MatchInfoDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.MatchInfoDto">MatchInfoDto</a>) ‑> <a title="valolyticspy.models.match.MatchInfoModel" href="#valolyticspy.models.match.MatchInfoModel">MatchInfoModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a MatchInfoModel instance from a MatchInfoDto instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>MatchInfoDto</code></dt>
<dd>The MatchInfoDto instance to convert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.MatchInfoModel" href="#valolyticspy.models.match.MatchInfoModel">MatchInfoModel</a></code></dt>
<dd>The converted MatchInfoModel instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: MatchInfoDto) -&gt; &#34;MatchInfoModel&#34;:
    &#34;&#34;&#34;
    Creates a MatchInfoModel instance from a MatchInfoDto instance.

    Args:
        dto (MatchInfoDto): The MatchInfoDto instance to convert.

    Returns:
        MatchInfoModel: The converted MatchInfoModel instance.
    &#34;&#34;&#34;
    return cls(
        **dto.model_dump(),
        gameStart=datetime.fromtimestamp(dto.gameStartMillis // 1000),
        map=get_map_from_mapId(dto.mapId)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.MatchModel"><code class="flex name class">
<span>class <span class="ident">MatchModel</span></span>
<span>(</span><span>data: <a title="valolyticspy.dtos.riot.match.MatchDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.MatchDto">MatchDto</a>, valolytics_client=None, region: <a title="valolyticspy.dtos.riot.enums.MatchRegion" href="../dtos/riot/enums.html#valolyticspy.dtos.riot.enums.MatchRegion">MatchRegion</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a match in the ValolyticsPy application.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>matchInfo</code></strong> :&ensp;<code><a title="valolyticspy.models.match.MatchInfoModel" href="#valolyticspy.models.match.MatchInfoModel">MatchInfoModel</a></code></dt>
<dd>Information about the match.</dd>
<dt><strong><code>teams</code></strong> :&ensp;<code>Dict[str, <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>]</code></dt>
<dd>A dictionary of teams in the match, where the key is the team ID and the value is the TeamModel object.</dd>
<dt><strong><code>players</code></strong> :&ensp;<code>Dict[str, <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>A dictionary of players in the match, where the key is the player's PUUID and the value is the PlayerModel object.</dd>
<dt><strong><code>observers</code></strong> :&ensp;<code>Optional[Dict[str, <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]]</code></dt>
<dd>A dictionary of observers in the match, where the key is the observer's PUUID and the value is the PlayerModel object. Defaults to None.</dd>
<dt><strong><code>roundResults</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.RoundResultModel" href="#valolyticspy.models.match.RoundResultModel">RoundResultModel</a>]</code></dt>
<dd>A list of round results in the match.</dd>
<dt><strong><code>raw_dto</code></strong> :&ensp;<code>Optional[MatchDto]</code></dt>
<dd>The raw MatchDto object used to initialize the MatchModel. Defaults to None.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(self, data: MatchDto, valolytics_client=None, region: MatchRegion=None): Initializes a MatchModel object.
get_puuids_from_team(self, team: TeamModel) -&gt; List[str]: Returns a list of PUUIDs from a specific team.
get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel: Returns the team that contains any of the given PUUIDs.</p>
<p>Initializes a MatchModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>MatchDto</code></dt>
<dd>The MatchDto object containing the match data.</dd>
<dt><strong><code>valolytics_client</code></strong> :&ensp;<code>optional</code></dt>
<dd>The Valolytics client object used to fetch player stats. Defaults to None.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code>optional</code></dt>
<dd>The region of the match. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchModel(MatchDto):
    &#34;&#34;&#34;
    Represents a match in the ValolyticsPy application.

    Attributes:
        matchInfo (MatchInfoModel): Information about the match.
        teams (Dict[str, TeamModel]): A dictionary of teams in the match, where the key is the team ID and the value is the TeamModel object.
        players (Dict[str, PlayerModel]): A dictionary of players in the match, where the key is the player&#39;s PUUID and the value is the PlayerModel object.
        observers (Optional[Dict[str, PlayerModel]]): A dictionary of observers in the match, where the key is the observer&#39;s PUUID and the value is the PlayerModel object. Defaults to None.
        roundResults (List[RoundResultModel]): A list of round results in the match.
        raw_dto (Optional[MatchDto]): The raw MatchDto object used to initialize the MatchModel. Defaults to None.

    Methods:
        __init__(self, data: MatchDto, valolytics_client=None, region: MatchRegion=None): Initializes a MatchModel object.
        get_puuids_from_team(self, team: TeamModel) -&gt; List[str]: Returns a list of PUUIDs from a specific team.
        get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel: Returns the team that contains any of the given PUUIDs.
    &#34;&#34;&#34;
    matchInfo: MatchInfoModel
    teams: Dict[str, TeamModel]
    players: Dict[str, PlayerModel]
    observers: Optional[Dict[str, PlayerModel]] = None
    roundResults: List[RoundResultModel]
    raw_dto: Optional[MatchDto] = None

    def __init__(self, data: MatchDto, valolytics_client=None, region: MatchRegion=None):
        &#34;&#34;&#34;
        Initializes a MatchModel object.

        Args:
            data (MatchDto): The MatchDto object containing the match data.
            valolytics_client (optional): The Valolytics client object used to fetch player stats. Defaults to None.
            region (optional): The region of the match. Defaults to None.
        &#34;&#34;&#34;
        teams: Dict[str, TeamModel] = {team.teamId: TeamModel.from_dto(team) for team in data.teams}
        players: Dict[str, PlayerModel] = {}
        observers: Dict[str, PlayerModel] = {}
        if valolytics_client != None and region != None:
            playerStats: Dict[str, PlayerStatsDto] = valolytics_client.get_playerstats_by_match_id(data.matchInfo.matchId, region)
        for player in data.players:
            if player.teamId != &#34;Neutral&#34;:
                if valolytics_client != None and region != None:
                    players[player.puuid] = PlayerModel.from_dto(player, teams[player.teamId], playerStats[player.puuid])
                else:
                    players[player.puuid] = PlayerModel.from_dto(player, teams[player.teamId])
            else:
                observers[player.puuid] = PlayerModel.from_dto(player, None)

        ordered_kills: List[KillModel] = []
        rounds: List[RoundResultModel] = []
        for round in data.roundResults:
            winningTeam: TeamModel = teams[round.winningTeam] if round.winningTeam != None else None
            bombPlanter: PlayerModel = players[round.bombPlanter] if round.bombPlanter != None else None
            bombDefuser: PlayerModel = players[round.bombDefuser] if round.bombDefuser != None else None
            
            player_stats: Dict[str, PlayerRoundStatsModel] = {}
            for player in round.playerStats:

                kills: List[KillModel] = []
                for kill in player.kills:
                    killer = players[kill.killer]
                    victim = players[kill.victim]
                    assistants: List[PlayerModel] = []

                    for assist in kill.assistants:
                        assistants.append(players[assist])

                    damageItem: Union[Weapon, Ability, str] = None

                    if (kill.finishingDamage.damageType == &#34;Weapon&#34;):
                        try:
                            damageItem = ValorantDTO.WEAPONS[kill.finishingDamage.damageItem.lower()]
                        except:
                            damageItem = kill.finishingDamage.damageItem
                    elif (kill.finishingDamage.damageType == &#34;Ability&#34;):
                        damageItemStr = kill.finishingDamage.damageItem if kill.finishingDamage.damageItem != &#34;GrenadeAbility&#34; else &#34;Grenade&#34;
                        
                        for ability in players[kill.killer].agent.abilities:
                            if ability.slot == damageItemStr:
                                damageItem = ability
                                break
                    elif (kill.finishingDamage.damageType == &#34;&#34;):
                        kill.finishingDamage.damageType = &#34;Bomb&#34;
                        damageItem = &#34;&#34;

                    kills.append(KillModel.from_dto(kill, killer, victim, assistants, FinishingDamageModel.from_dto(kill.finishingDamage, damageItem)))
                    ordered_kills.extend(kills)

                damages: List[DamageModel] = []
                for damage in player.damage:
                    damages.append(DamageModel.from_dto(damage, players[damage.receiver]))

                player_stats[player.puuid] = PlayerRoundStatsModel.from_dto(player, players[player.puuid], kills, damages)

            ordered_kills.sort(key=lambda kill: kill.timeSinceRoundStartMillis)
            rounds.append(RoundResultModel.from_dto(round, winningTeam, bombPlanter, bombDefuser, player_stats, ordered_kills))
            players

        super().__init__(
            matchInfo=MatchInfoModel.from_dto(data.matchInfo),
            teams=teams,
            players=players,
            coaches=data.coaches,
            roundResults=rounds
        )
        self.observers = observers,
        self.raw_dto = data

    def get_puuids_from_team(self, team: TeamModel) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns a list of PUUIDs from a specific team.

        Args:
            team (TeamModel): The team to get the PUUIDs from.

        Returns:
            List[str]: A list of PUUIDs from the specified team.
        &#34;&#34;&#34;
        puuids: List[str] = []
        for player in self.players.values():
            if player.team == team:
                puuids.append(player.puuid)
        return puuids

    def get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel:
        &#34;&#34;&#34;
        Returns the team that contains any of the given PUUIDs.

        Args:
            puuids (List[str]): The list of PUUIDs to check.

        Returns:
            TeamModel: The team that contains any of the given PUUIDs.
        &#34;&#34;&#34;
        any_in_team_red = any(element in set(self.get_puuids_from_team(self.teams[TeamId.RED.value])) for element in puuids)
        any_in_team_blue = any(element in set(self.get_puuids_from_team(self.teams[TeamId.BLUE.value])) for element in puuids)

        if any_in_team_red and not any_in_team_blue:
            return self.teams[TeamId.RED.value]
        elif any_in_team_blue and not any_in_team_red:
            return self.teams[TeamId.BLUE.value]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.MatchDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.MatchDto">MatchDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.MatchModel.matchInfo"><code class="name">var <span class="ident">matchInfo</span> : <a title="valolyticspy.models.match.MatchInfoModel" href="#valolyticspy.models.match.MatchInfoModel">MatchInfoModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.observers"><code class="name">var <span class="ident">observers</span> : Optional[Dict[str, <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.players"><code class="name">var <span class="ident">players</span> : Dict[str, <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.raw_dto"><code class="name">var <span class="ident">raw_dto</span> : Optional[<a title="valolyticspy.dtos.riot.match.MatchDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.MatchDto">MatchDto</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.roundResults"><code class="name">var <span class="ident">roundResults</span> : List[<a title="valolyticspy.models.match.RoundResultModel" href="#valolyticspy.models.match.RoundResultModel">RoundResultModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.MatchModel.teams"><code class="name">var <span class="ident">teams</span> : Dict[str, <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="valolyticspy.models.match.MatchModel.get_puuids_from_team"><code class="name flex">
<span>def <span class="ident">get_puuids_from_team</span></span>(<span>self, team: <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of PUUIDs from a specific team.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>team</code></strong> :&ensp;<code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The team to get the PUUIDs from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>A list of PUUIDs from the specified team.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_puuids_from_team(self, team: TeamModel) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns a list of PUUIDs from a specific team.

    Args:
        team (TeamModel): The team to get the PUUIDs from.

    Returns:
        List[str]: A list of PUUIDs from the specified team.
    &#34;&#34;&#34;
    puuids: List[str] = []
    for player in self.players.values():
        if player.team == team:
            puuids.append(player.puuid)
    return puuids</code></pre>
</details>
</dd>
<dt id="valolyticspy.models.match.MatchModel.get_team_by_puuids"><code class="name flex">
<span>def <span class="ident">get_team_by_puuids</span></span>(<span>self, puuids: List[str]) ‑> <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the team that contains any of the given PUUIDs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>puuids</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The list of PUUIDs to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The team that contains any of the given PUUIDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_team_by_puuids(self, puuids: List[str]) -&gt; TeamModel:
    &#34;&#34;&#34;
    Returns the team that contains any of the given PUUIDs.

    Args:
        puuids (List[str]): The list of PUUIDs to check.

    Returns:
        TeamModel: The team that contains any of the given PUUIDs.
    &#34;&#34;&#34;
    any_in_team_red = any(element in set(self.get_puuids_from_team(self.teams[TeamId.RED.value])) for element in puuids)
    any_in_team_blue = any(element in set(self.get_puuids_from_team(self.teams[TeamId.BLUE.value])) for element in puuids)

    if any_in_team_red and not any_in_team_blue:
        return self.teams[TeamId.RED.value]
    elif any_in_team_blue and not any_in_team_red:
        return self.teams[TeamId.BLUE.value]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.PlayerModel"><code class="flex name class">
<span>class <span class="ident">PlayerModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a player in the game.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>agent</code></strong> :&ensp;<code>Optional[Agent]</code></dt>
<dd>The agent chosen by the player.</dd>
<dt><strong><code>competitiveTier</code></strong> :&ensp;<code>Tier</code></dt>
<dd>The competitive tier of the player.</dd>
<dt><strong><code>playerCard</code></strong> :&ensp;<code>PlayerCard</code></dt>
<dd>The player's selected card.</dd>
<dt><strong><code>playerTitle</code></strong> :&ensp;<code>Optional[PlayerTitle]</code></dt>
<dd>The player's selected title.</dd>
<dt><strong><code>team</code></strong> :&ensp;<code>Optional[<a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>]</code></dt>
<dd>The team the player belongs to.</dd>
<dt><strong><code>stats</code></strong> :&ensp;<code>Optional[Union[SideStatsDto, NormalPlayerStatsDto]]</code></dt>
<dd>The player's statistics.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; PlayerModel:
Creates a PlayerModel instance from a PlayerDto object.
<strong>hash</strong>(self) -&gt; int:
Returns the hash value of the PlayerModel instance.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlayerModel(PlayerDto):
    &#34;&#34;&#34;
    Represents a player in the game.

    Attributes:
        agent (Optional[Agent]): The agent chosen by the player.
        competitiveTier (Tier): The competitive tier of the player.
        playerCard (PlayerCard): The player&#39;s selected card.
        playerTitle (Optional[PlayerTitle]): The player&#39;s selected title.
        team (Optional[TeamModel]): The team the player belongs to.
        stats (Optional[Union[SideStatsDto, NormalPlayerStatsDto]]): The player&#39;s statistics.

    Methods:
        from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; PlayerModel:
            Creates a PlayerModel instance from a PlayerDto object.
        __hash__(self) -&gt; int:
            Returns the hash value of the PlayerModel instance.
    &#34;&#34;&#34;

    agent: Optional[Agent] = None
    competitiveTier: Tier
    playerCard: PlayerCard
    playerTitle: Optional[PlayerTitle] = None
    team: Optional[TeamModel] = None
    stats: Optional[Union[SideStatsDto, NormalPlayerStatsDto]] = None

    @classmethod
    def from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; &#34;PlayerModel&#34;:
        &#34;&#34;&#34;
        Converts a PlayerDto object to a PlayerModel object.

        Args:
            dto (PlayerDto): The PlayerDto object to convert.
            team (TeamModel): The TeamModel object to associate with the player.
            playerStats (PlayerStatsDto, optional): The PlayerStatsDto object to use for player stats. Defaults to None.

        Returns:
            PlayerModel: The converted PlayerModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;competitiveTier&#34;)
        dumped_model.pop(&#34;playerCard&#34;)
        dumped_model.pop(&#34;playerTitle&#34;)
        dumped_model.pop(&#34;stats&#34;)
        return cls(
            **dumped_model,
            agent=ValorantDTO.AGENTS[dto.characterId.lower()] if dto.characterId != None else None,
            competitiveTier=get_competitive_tier_from_tier(dto.competitiveTier),
            playerCard=ValorantDTO.PLAYER_CARDS[dto.playerCard],
            playerTitle=ValorantDTO.PLAYER_TITLES[dto.playerTitle] if dto.playerTitle != &#34;&#34; else None,
            team=team,
            stats=playerStats.side if playerStats != None else dto.stats
        )

    def __hash__(self) -&gt; int:
            &#34;&#34;&#34;
            Returns the hash value of the object based on its &#39;puuid&#39; attribute.

            Returns:
                int: The hash value of the object.
            &#34;&#34;&#34;
            return hash(self.puuid)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.PlayerDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerDto">PlayerDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.PlayerModel.agent"><code class="name">var <span class="ident">agent</span> : Optional[<a title="valolyticspy.dtos.valorant_api.agent.Agent" href="../dtos/valorant_api/agent.html#valolyticspy.dtos.valorant_api.agent.Agent">Agent</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.competitiveTier"><code class="name">var <span class="ident">competitiveTier</span> : <a title="valolyticspy.dtos.valorant_api.competitive_tier.Tier" href="../dtos/valorant_api/competitive_tier.html#valolyticspy.dtos.valorant_api.competitive_tier.Tier">Tier</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.playerCard"><code class="name">var <span class="ident">playerCard</span> : <a title="valolyticspy.dtos.valorant_api.player_card.PlayerCard" href="../dtos/valorant_api/player_card.html#valolyticspy.dtos.valorant_api.player_card.PlayerCard">PlayerCard</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.playerTitle"><code class="name">var <span class="ident">playerTitle</span> : Optional[<a title="valolyticspy.dtos.valorant_api.player_title.PlayerTitle" href="../dtos/valorant_api/player_title.html#valolyticspy.dtos.valorant_api.player_title.PlayerTitle">PlayerTitle</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.stats"><code class="name">var <span class="ident">stats</span> : Union[<a title="valolyticspy.dtos.valolytics.playerstats.SideStatsDto" href="../dtos/valolytics/playerstats.html#valolyticspy.dtos.valolytics.playerstats.SideStatsDto">SideStatsDto</a>, <a title="valolyticspy.dtos.riot.match.PlayerStatsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerStatsDto">PlayerStatsDto</a>, ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerModel.team"><code class="name">var <span class="ident">team</span> : Optional[<a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.PlayerModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.PlayerDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerDto">PlayerDto</a>, team: <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>, playerStats: <a title="valolyticspy.dtos.valolytics.playerstats.PlayerStatsDto" href="../dtos/valolytics/playerstats.html#valolyticspy.dtos.valolytics.playerstats.PlayerStatsDto">PlayerStatsDto</a> = None) ‑> <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a PlayerDto object to a PlayerModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>PlayerDto</code></dt>
<dd>The PlayerDto object to convert.</dd>
<dt><strong><code>team</code></strong> :&ensp;<code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The TeamModel object to associate with the player.</dd>
<dt><strong><code>playerStats</code></strong> :&ensp;<code>PlayerStatsDto</code>, optional</dt>
<dd>The PlayerStatsDto object to use for player stats. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The converted PlayerModel object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: PlayerDto, team: TeamModel, playerStats: PlayerStatsDto = None) -&gt; &#34;PlayerModel&#34;:
    &#34;&#34;&#34;
    Converts a PlayerDto object to a PlayerModel object.

    Args:
        dto (PlayerDto): The PlayerDto object to convert.
        team (TeamModel): The TeamModel object to associate with the player.
        playerStats (PlayerStatsDto, optional): The PlayerStatsDto object to use for player stats. Defaults to None.

    Returns:
        PlayerModel: The converted PlayerModel object.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;competitiveTier&#34;)
    dumped_model.pop(&#34;playerCard&#34;)
    dumped_model.pop(&#34;playerTitle&#34;)
    dumped_model.pop(&#34;stats&#34;)
    return cls(
        **dumped_model,
        agent=ValorantDTO.AGENTS[dto.characterId.lower()] if dto.characterId != None else None,
        competitiveTier=get_competitive_tier_from_tier(dto.competitiveTier),
        playerCard=ValorantDTO.PLAYER_CARDS[dto.playerCard],
        playerTitle=ValorantDTO.PLAYER_TITLES[dto.playerTitle] if dto.playerTitle != &#34;&#34; else None,
        team=team,
        stats=playerStats.side if playerStats != None else dto.stats
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel"><code class="flex name class">
<span>class <span class="ident">PlayerRoundStatsModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the model for player round statistics.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>player</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player associated with the round statistics.</dd>
<dt><strong><code>kills</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>The list of kills made by the player.</dd>
<dt><strong><code>damage</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a>]</code></dt>
<dd>The list of damage inflicted by the player.</dd>
<dt><strong><code>economy</code></strong> :&ensp;<code><a title="valolyticspy.models.match.EconomyModel" href="#valolyticspy.models.match.EconomyModel">EconomyModel</a></code></dt>
<dd>The economy information of the player.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; PlayerRoundStatsModel:
Creates a new instance of PlayerRoundStatsModel from the provided DTO and related models.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlayerRoundStatsModel(PlayerRoundStatsDto):
    &#34;&#34;&#34;
    Represents the model for player round statistics.

    Attributes:
        player (PlayerModel): The player associated with the round statistics.
        kills (List[KillModel]): The list of kills made by the player.
        damage (List[DamageModel]): The list of damage inflicted by the player.
        economy (EconomyModel): The economy information of the player.

    Methods:
        from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; PlayerRoundStatsModel:
            Creates a new instance of PlayerRoundStatsModel from the provided DTO and related models.
    &#34;&#34;&#34;
    player: PlayerModel
    kills: List[KillModel]
    damage: List[DamageModel]
    economy: EconomyModel

    @classmethod
    def from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; &#34;PlayerRoundStatsModel&#34;:
        &#34;&#34;&#34;
        Converts a PlayerRoundStatsDto object to a PlayerRoundStatsModel object.

        Args:
            dto (PlayerRoundStatsDto): The PlayerRoundStatsDto object to convert.
            player (PlayerModel): The PlayerModel object associated with the stats.
            kills (List[KillModel]): A list of KillModel objects representing the kills made by the player.
            damage (List[DamageModel]): A list of DamageModel objects representing the damage dealt by the player.

        Returns:
            PlayerRoundStatsModel: The converted PlayerRoundStatsModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;kills&#34;)
        dumped_model.pop(&#34;damage&#34;)
        dumped_model.pop(&#34;economy&#34;)
        return cls(
            **dumped_model,
            player=player,
            kills=kills,
            damage=damage,
            economy=EconomyModel.from_dto(dto.economy)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.PlayerRoundStatsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerRoundStatsDto">PlayerRoundStatsDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.damage"><code class="name">var <span class="ident">damage</span> : List[<a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.economy"><code class="name">var <span class="ident">economy</span> : <a title="valolyticspy.models.match.EconomyModel" href="#valolyticspy.models.match.EconomyModel">EconomyModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.kills"><code class="name">var <span class="ident">kills</span> : List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.player"><code class="name">var <span class="ident">player</span> : <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.PlayerRoundStatsModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.PlayerRoundStatsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerRoundStatsDto">PlayerRoundStatsDto</a>, player: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>, kills: List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>], damage: List[<a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a>]) ‑> <a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a PlayerRoundStatsDto object to a PlayerRoundStatsModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>PlayerRoundStatsDto</code></dt>
<dd>The PlayerRoundStatsDto object to convert.</dd>
<dt><strong><code>player</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The PlayerModel object associated with the stats.</dd>
<dt><strong><code>kills</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>A list of KillModel objects representing the kills made by the player.</dd>
<dt><strong><code>damage</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a>]</code></dt>
<dd>A list of DamageModel objects representing the damage dealt by the player.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a></code></dt>
<dd>The converted PlayerRoundStatsModel object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: PlayerRoundStatsDto, player: PlayerModel, kills: List[KillModel], damage: List[DamageModel]) -&gt; &#34;PlayerRoundStatsModel&#34;:
    &#34;&#34;&#34;
    Converts a PlayerRoundStatsDto object to a PlayerRoundStatsModel object.

    Args:
        dto (PlayerRoundStatsDto): The PlayerRoundStatsDto object to convert.
        player (PlayerModel): The PlayerModel object associated with the stats.
        kills (List[KillModel]): A list of KillModel objects representing the kills made by the player.
        damage (List[DamageModel]): A list of DamageModel objects representing the damage dealt by the player.

    Returns:
        PlayerRoundStatsModel: The converted PlayerRoundStatsModel object.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;kills&#34;)
    dumped_model.pop(&#34;damage&#34;)
    dumped_model.pop(&#34;economy&#34;)
    return cls(
        **dumped_model,
        player=player,
        kills=kills,
        damage=damage,
        economy=EconomyModel.from_dto(dto.economy)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel"><code class="flex name class">
<span>class <span class="ident">RoundResultModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a round result in a match.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>roundCeremony</code></strong> :&ensp;<code>Optional[Ceremony]</code></dt>
<dd>The ceremony associated with the round.</dd>
<dt><strong><code>winningTeam</code></strong> :&ensp;<code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The winning team of the round.</dd>
<dt><strong><code>bombPlanter</code></strong> :&ensp;<code>Optional[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>The player who planted the bomb.</dd>
<dt><strong><code>isBombPlantAfterRoundEnd</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether the bomb was planted after the round ended.</dd>
<dt><strong><code>bombDefuser</code></strong> :&ensp;<code>Optional[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>The player who defused the bomb.</dd>
<dt><strong><code>plantPlayerLocations</code></strong> :&ensp;<code>Optional[Dict[str, PlayerLocationsDto]]</code></dt>
<dd>The locations of players who planted the bomb.</dd>
<dt><strong><code>defusePlayerLocations</code></strong> :&ensp;<code>Optional[Dict[str, PlayerLocationsDto]]</code></dt>
<dd>The locations of players who defused the bomb.</dd>
<dt><strong><code>playerStats</code></strong> :&ensp;<code>Dict[str, <a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a>]</code></dt>
<dd>The statistics of players in the round.</dd>
<dt><strong><code>kills</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>The kills that occurred in the round.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoundResultModel(RoundResultDto):
    &#34;&#34;&#34;
    Represents a round result in a match.

    Attributes:
        roundCeremony (Optional[Ceremony]): The ceremony associated with the round.
        winningTeam (TeamModel): The winning team of the round.
        bombPlanter (Optional[PlayerModel]): The player who planted the bomb.
        isBombPlantAfterRoundEnd (Optional[bool]): Whether the bomb was planted after the round ended.
        bombDefuser (Optional[PlayerModel]): The player who defused the bomb.
        plantPlayerLocations (Optional[Dict[str, PlayerLocationsDto]]): The locations of players who planted the bomb.
        defusePlayerLocations (Optional[Dict[str, PlayerLocationsDto]]): The locations of players who defused the bomb.
        playerStats (Dict[str, PlayerRoundStatsModel]): The statistics of players in the round.
        kills (List[KillModel]): The kills that occurred in the round.
    &#34;&#34;&#34;

    roundCeremony: Optional[Ceremony] = None
    winningTeam: TeamModel
    bombPlanter: Optional[PlayerModel] = None
    isBombPlantAfterRoundEnd: Optional[bool] = None
    bombDefuser: Optional[PlayerModel] = None
    plantPlayerLocations: Optional[Dict[str, PlayerLocationsDto]] = None
    defusePlayerLocations: Optional[Dict[str, PlayerLocationsDto]] = None
    playerStats: Dict[str, PlayerRoundStatsModel]
    kills: List[KillModel]

    @classmethod
    def from_dto(cls, dto: RoundResultDto, winningTeam: TeamModel, bombPlanter: PlayerModel, bombDefuser: PlayerModel, playerStats: Dict[str, PlayerRoundStatsModel], kills: List[KillModel]) -&gt; &#34;RoundResultModel&#34;:
        &#34;&#34;&#34;
        Converts a RoundResultDto object into a RoundResultModel object.

        Args:
            dto (RoundResultDto): The RoundResultDto object to convert.
            winningTeam (TeamModel): The winning team of the round.
            bombPlanter (PlayerModel): The player who planted the bomb.
            bombDefuser (PlayerModel): The player who defused the bomb.
            playerStats (Dict[str, PlayerRoundStatsModel]): A dictionary of player round statistics.
            kills (List[KillModel]): A list of kill events.

        Returns:
            RoundResultModel: The converted RoundResultModel object.
        &#34;&#34;&#34;
        dumped_model = dto.model_dump()
        dumped_model.pop(&#34;roundCeremony&#34;)
        dumped_model.pop(&#34;winningTeam&#34;)
        dumped_model.pop(&#34;bombPlanter&#34;)
        dumped_model.pop(&#34;bombDefuser&#34;)
        dumped_model.pop(&#34;plantPlayerLocations&#34;)
        dumped_model.pop(&#34;defusePlayerLocations&#34;)
        dumped_model.pop(&#34;playerStats&#34;)

        match dto.roundResult:
            case &#34;Eliminated&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; kills[-1].timeSinceRoundStartMillis else False
            case &#34;Round timer expired&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; 100*1000 else False
            case _: isBombPlantAfterRoundEnd = None

        return cls(
            **dumped_model,
            roundCeremony=get_ceremony_from_roundCeremony(dto.roundCeremony),
            winningTeam=winningTeam,
            bombPlanter=bombPlanter,
            isBombPlantAfterRoundEnd=isBombPlantAfterRoundEnd,
            bombDefuser=bombDefuser,
            plantPlayerLocations={player_location.puuid: player_location for player_location in dto.plantPlayerLocations} if dto.plantPlayerLocations != None else None,
            defusePlayerLocations={player_location.puuid: player_location for player_location in dto.defusePlayerLocations} if dto.defusePlayerLocations != None else None,
            playerStats=playerStats,
            kills=kills
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.RoundResultDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.RoundResultDto">RoundResultDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.RoundResultModel.bombDefuser"><code class="name">var <span class="ident">bombDefuser</span> : Optional[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.bombPlanter"><code class="name">var <span class="ident">bombPlanter</span> : Optional[<a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.defusePlayerLocations"><code class="name">var <span class="ident">defusePlayerLocations</span> : Optional[Dict[str, <a title="valolyticspy.dtos.riot.match.PlayerLocationsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerLocationsDto">PlayerLocationsDto</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.isBombPlantAfterRoundEnd"><code class="name">var <span class="ident">isBombPlantAfterRoundEnd</span> : Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.kills"><code class="name">var <span class="ident">kills</span> : List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.plantPlayerLocations"><code class="name">var <span class="ident">plantPlayerLocations</span> : Optional[Dict[str, <a title="valolyticspy.dtos.riot.match.PlayerLocationsDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.PlayerLocationsDto">PlayerLocationsDto</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.playerStats"><code class="name">var <span class="ident">playerStats</span> : Dict[str, <a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.roundCeremony"><code class="name">var <span class="ident">roundCeremony</span> : Optional[<a title="valolyticspy.dtos.valorant_api.ceremony.Ceremony" href="../dtos/valorant_api/ceremony.html#valolyticspy.dtos.valorant_api.ceremony.Ceremony">Ceremony</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.RoundResultModel.winningTeam"><code class="name">var <span class="ident">winningTeam</span> : <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.RoundResultModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.RoundResultDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.RoundResultDto">RoundResultDto</a>, winningTeam: <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a>, bombPlanter: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>, bombDefuser: <a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a>, playerStats: Dict[str, <a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a>], kills: List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]) ‑> <a title="valolyticspy.models.match.RoundResultModel" href="#valolyticspy.models.match.RoundResultModel">RoundResultModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a RoundResultDto object into a RoundResultModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>RoundResultDto</code></dt>
<dd>The RoundResultDto object to convert.</dd>
<dt><strong><code>winningTeam</code></strong> :&ensp;<code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The winning team of the round.</dd>
<dt><strong><code>bombPlanter</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who planted the bomb.</dd>
<dt><strong><code>bombDefuser</code></strong> :&ensp;<code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></dt>
<dd>The player who defused the bomb.</dd>
<dt><strong><code>playerStats</code></strong> :&ensp;<code>Dict[str, <a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a>]</code></dt>
<dd>A dictionary of player round statistics.</dd>
<dt><strong><code>kills</code></strong> :&ensp;<code>List[<a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a>]</code></dt>
<dd>A list of kill events.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.RoundResultModel" href="#valolyticspy.models.match.RoundResultModel">RoundResultModel</a></code></dt>
<dd>The converted RoundResultModel object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto: RoundResultDto, winningTeam: TeamModel, bombPlanter: PlayerModel, bombDefuser: PlayerModel, playerStats: Dict[str, PlayerRoundStatsModel], kills: List[KillModel]) -&gt; &#34;RoundResultModel&#34;:
    &#34;&#34;&#34;
    Converts a RoundResultDto object into a RoundResultModel object.

    Args:
        dto (RoundResultDto): The RoundResultDto object to convert.
        winningTeam (TeamModel): The winning team of the round.
        bombPlanter (PlayerModel): The player who planted the bomb.
        bombDefuser (PlayerModel): The player who defused the bomb.
        playerStats (Dict[str, PlayerRoundStatsModel]): A dictionary of player round statistics.
        kills (List[KillModel]): A list of kill events.

    Returns:
        RoundResultModel: The converted RoundResultModel object.
    &#34;&#34;&#34;
    dumped_model = dto.model_dump()
    dumped_model.pop(&#34;roundCeremony&#34;)
    dumped_model.pop(&#34;winningTeam&#34;)
    dumped_model.pop(&#34;bombPlanter&#34;)
    dumped_model.pop(&#34;bombDefuser&#34;)
    dumped_model.pop(&#34;plantPlayerLocations&#34;)
    dumped_model.pop(&#34;defusePlayerLocations&#34;)
    dumped_model.pop(&#34;playerStats&#34;)

    match dto.roundResult:
        case &#34;Eliminated&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; kills[-1].timeSinceRoundStartMillis else False
        case &#34;Round timer expired&#34;: isBombPlantAfterRoundEnd = True if dto.plantRoundTime &gt; 100*1000 else False
        case _: isBombPlantAfterRoundEnd = None

    return cls(
        **dumped_model,
        roundCeremony=get_ceremony_from_roundCeremony(dto.roundCeremony),
        winningTeam=winningTeam,
        bombPlanter=bombPlanter,
        isBombPlantAfterRoundEnd=isBombPlantAfterRoundEnd,
        bombDefuser=bombDefuser,
        plantPlayerLocations={player_location.puuid: player_location for player_location in dto.plantPlayerLocations} if dto.plantPlayerLocations != None else None,
        defusePlayerLocations={player_location.puuid: player_location for player_location in dto.defusePlayerLocations} if dto.defusePlayerLocations != None else None,
        playerStats=playerStats,
        kills=kills
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.Side"><code class="flex name class">
<span>class <span class="ident">Side</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum representing the sides in a match.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ATTACK</code></strong> :&ensp;<code>str</code></dt>
<dd>Represents the attacking side.</dd>
<dt><strong><code>DEFENSE</code></strong> :&ensp;<code>str</code></dt>
<dd>Represents the defending side.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Side(Enum):
    &#34;&#34;&#34;
    Enum representing the sides in a match.

    Attributes:
        ATTACK (str): Represents the attacking side.
        DEFENSE (str): Represents the defending side.
    &#34;&#34;&#34;
    ATTACK = &#34;Attack&#34;
    DEFENSE = &#34;Defense&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.Side.ATTACK"><code class="name">var <span class="ident">ATTACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.Side.DEFENSE"><code class="name">var <span class="ident">DEFENSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.TeamId"><code class="flex name class">
<span>class <span class="ident">TeamId</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum representing the team ID.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>RED</code></strong> :&ensp;<code>str</code></dt>
<dd>The team ID for the red team.</dd>
<dt><strong><code>BLUE</code></strong> :&ensp;<code>str</code></dt>
<dd>The team ID for the blue team.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TeamId(Enum):
    &#34;&#34;&#34;
    Enum representing the team ID.

    Attributes:
        RED (str): The team ID for the red team.
        BLUE (str): The team ID for the blue team.
    &#34;&#34;&#34;
    RED = &#34;Red&#34;
    BLUE = &#34;Blue&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.TeamId.BLUE"><code class="name">var <span class="ident">BLUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.TeamId.RED"><code class="name">var <span class="ident">RED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="valolyticspy.models.match.TeamModel"><code class="flex name class">
<span>class <span class="ident">TeamModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a team model.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>teamId</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the team.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TeamModel(TeamDto):
    &#34;&#34;&#34;
    Represents a team model.

    Attributes:
        teamId (int): The ID of the team.
    &#34;&#34;&#34;

    @classmethod
    def from_dto(cls, dto:TeamDto) -&gt; &#34;TeamModel&#34;:
        &#34;&#34;&#34;
        Creates a TeamModel instance from a TeamDto instance.

        Args:
            dto (TeamDto): The TeamDto instance.

        Returns:
            TeamModel: The created TeamModel instance.
        &#34;&#34;&#34;
        return cls(**dto.model_dump())

    def side(self, roundNum:int) -&gt; Side:
        &#34;&#34;&#34;
        Determines the side of the team based on the round number.

        Args:
            roundNum (int): The round number.

        Returns:
            Side: The side of the team.
        &#34;&#34;&#34;
        if(roundNum &lt; 12 or (roundNum &gt;= 24 and roundNum % 2 == 0)):
            return Side.ATTACK if self.teamId == TeamId.RED.value else Side.DEFENSE
        else:
            return Side.DEFENSE if self.teamId == TeamId.RED.value else Side.ATTACK</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="valolyticspy.dtos.riot.match.TeamDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.TeamDto">TeamDto</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="valolyticspy.models.match.TeamModel.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.TeamModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="valolyticspy.models.match.TeamModel.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="valolyticspy.models.match.TeamModel.from_dto"><code class="name flex">
<span>def <span class="ident">from_dto</span></span>(<span>dto: <a title="valolyticspy.dtos.riot.match.TeamDto" href="../dtos/riot/match.html#valolyticspy.dtos.riot.match.TeamDto">TeamDto</a>) ‑> <a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TeamModel instance from a TeamDto instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dto</code></strong> :&ensp;<code>TeamDto</code></dt>
<dd>The TeamDto instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></dt>
<dd>The created TeamModel instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dto(cls, dto:TeamDto) -&gt; &#34;TeamModel&#34;:
    &#34;&#34;&#34;
    Creates a TeamModel instance from a TeamDto instance.

    Args:
        dto (TeamDto): The TeamDto instance.

    Returns:
        TeamModel: The created TeamModel instance.
    &#34;&#34;&#34;
    return cls(**dto.model_dump())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="valolyticspy.models.match.TeamModel.side"><code class="name flex">
<span>def <span class="ident">side</span></span>(<span>self, roundNum: int) ‑> <a title="valolyticspy.models.match.Side" href="#valolyticspy.models.match.Side">Side</a></span>
</code></dt>
<dd>
<div class="desc"><p>Determines the side of the team based on the round number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>roundNum</code></strong> :&ensp;<code>int</code></dt>
<dd>The round number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="valolyticspy.models.match.Side" href="#valolyticspy.models.match.Side">Side</a></code></dt>
<dd>The side of the team.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def side(self, roundNum:int) -&gt; Side:
    &#34;&#34;&#34;
    Determines the side of the team based on the round number.

    Args:
        roundNum (int): The round number.

    Returns:
        Side: The side of the team.
    &#34;&#34;&#34;
    if(roundNum &lt; 12 or (roundNum &gt;= 24 and roundNum % 2 == 0)):
        return Side.ATTACK if self.teamId == TeamId.RED.value else Side.DEFENSE
    else:
        return Side.DEFENSE if self.teamId == TeamId.RED.value else Side.ATTACK</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="valolyticspy.models" href="index.html">valolyticspy.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="valolyticspy.models.match.AbilityCastsModel" href="#valolyticspy.models.match.AbilityCastsModel">AbilityCastsModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.AbilityCastsModel.model_computed_fields" href="#valolyticspy.models.match.AbilityCastsModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.AbilityCastsModel.model_config" href="#valolyticspy.models.match.AbilityCastsModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.AbilityCastsModel.model_fields" href="#valolyticspy.models.match.AbilityCastsModel.model_fields">model_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.DamageModel" href="#valolyticspy.models.match.DamageModel">DamageModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.DamageModel.from_dto" href="#valolyticspy.models.match.DamageModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.DamageModel.model_computed_fields" href="#valolyticspy.models.match.DamageModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.DamageModel.model_config" href="#valolyticspy.models.match.DamageModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.DamageModel.model_fields" href="#valolyticspy.models.match.DamageModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.DamageModel.receiver" href="#valolyticspy.models.match.DamageModel.receiver">receiver</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.EconomyModel" href="#valolyticspy.models.match.EconomyModel">EconomyModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.EconomyModel.armor" href="#valolyticspy.models.match.EconomyModel.armor">armor</a></code></li>
<li><code><a title="valolyticspy.models.match.EconomyModel.from_dto" href="#valolyticspy.models.match.EconomyModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.EconomyModel.model_computed_fields" href="#valolyticspy.models.match.EconomyModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.EconomyModel.model_config" href="#valolyticspy.models.match.EconomyModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.EconomyModel.model_fields" href="#valolyticspy.models.match.EconomyModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.EconomyModel.weapon" href="#valolyticspy.models.match.EconomyModel.weapon">weapon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.FinishingDamageModel" href="#valolyticspy.models.match.FinishingDamageModel">FinishingDamageModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.FinishingDamageModel.damageItem" href="#valolyticspy.models.match.FinishingDamageModel.damageItem">damageItem</a></code></li>
<li><code><a title="valolyticspy.models.match.FinishingDamageModel.from_dto" href="#valolyticspy.models.match.FinishingDamageModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.FinishingDamageModel.model_computed_fields" href="#valolyticspy.models.match.FinishingDamageModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.FinishingDamageModel.model_config" href="#valolyticspy.models.match.FinishingDamageModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.FinishingDamageModel.model_fields" href="#valolyticspy.models.match.FinishingDamageModel.model_fields">model_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.KillModel" href="#valolyticspy.models.match.KillModel">KillModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.KillModel.assistants" href="#valolyticspy.models.match.KillModel.assistants">assistants</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.finishingDamage" href="#valolyticspy.models.match.KillModel.finishingDamage">finishingDamage</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.from_dto" href="#valolyticspy.models.match.KillModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.killer" href="#valolyticspy.models.match.KillModel.killer">killer</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.model_computed_fields" href="#valolyticspy.models.match.KillModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.model_config" href="#valolyticspy.models.match.KillModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.model_fields" href="#valolyticspy.models.match.KillModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.playerLocations" href="#valolyticspy.models.match.KillModel.playerLocations">playerLocations</a></code></li>
<li><code><a title="valolyticspy.models.match.KillModel.victim" href="#valolyticspy.models.match.KillModel.victim">victim</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.MatchInfoModel" href="#valolyticspy.models.match.MatchInfoModel">MatchInfoModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.MatchInfoModel.from_dto" href="#valolyticspy.models.match.MatchInfoModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchInfoModel.gameStart" href="#valolyticspy.models.match.MatchInfoModel.gameStart">gameStart</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchInfoModel.map" href="#valolyticspy.models.match.MatchInfoModel.map">map</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchInfoModel.model_computed_fields" href="#valolyticspy.models.match.MatchInfoModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchInfoModel.model_config" href="#valolyticspy.models.match.MatchInfoModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchInfoModel.model_fields" href="#valolyticspy.models.match.MatchInfoModel.model_fields">model_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.MatchModel" href="#valolyticspy.models.match.MatchModel">MatchModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.MatchModel.get_puuids_from_team" href="#valolyticspy.models.match.MatchModel.get_puuids_from_team">get_puuids_from_team</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.get_team_by_puuids" href="#valolyticspy.models.match.MatchModel.get_team_by_puuids">get_team_by_puuids</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.matchInfo" href="#valolyticspy.models.match.MatchModel.matchInfo">matchInfo</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.model_computed_fields" href="#valolyticspy.models.match.MatchModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.model_config" href="#valolyticspy.models.match.MatchModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.model_fields" href="#valolyticspy.models.match.MatchModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.observers" href="#valolyticspy.models.match.MatchModel.observers">observers</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.players" href="#valolyticspy.models.match.MatchModel.players">players</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.raw_dto" href="#valolyticspy.models.match.MatchModel.raw_dto">raw_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.roundResults" href="#valolyticspy.models.match.MatchModel.roundResults">roundResults</a></code></li>
<li><code><a title="valolyticspy.models.match.MatchModel.teams" href="#valolyticspy.models.match.MatchModel.teams">teams</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.PlayerModel" href="#valolyticspy.models.match.PlayerModel">PlayerModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.PlayerModel.agent" href="#valolyticspy.models.match.PlayerModel.agent">agent</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.competitiveTier" href="#valolyticspy.models.match.PlayerModel.competitiveTier">competitiveTier</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.from_dto" href="#valolyticspy.models.match.PlayerModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.model_computed_fields" href="#valolyticspy.models.match.PlayerModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.model_config" href="#valolyticspy.models.match.PlayerModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.model_fields" href="#valolyticspy.models.match.PlayerModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.playerCard" href="#valolyticspy.models.match.PlayerModel.playerCard">playerCard</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.playerTitle" href="#valolyticspy.models.match.PlayerModel.playerTitle">playerTitle</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.stats" href="#valolyticspy.models.match.PlayerModel.stats">stats</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerModel.team" href="#valolyticspy.models.match.PlayerModel.team">team</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.PlayerRoundStatsModel" href="#valolyticspy.models.match.PlayerRoundStatsModel">PlayerRoundStatsModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.damage" href="#valolyticspy.models.match.PlayerRoundStatsModel.damage">damage</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.economy" href="#valolyticspy.models.match.PlayerRoundStatsModel.economy">economy</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.from_dto" href="#valolyticspy.models.match.PlayerRoundStatsModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.kills" href="#valolyticspy.models.match.PlayerRoundStatsModel.kills">kills</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.model_computed_fields" href="#valolyticspy.models.match.PlayerRoundStatsModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.model_config" href="#valolyticspy.models.match.PlayerRoundStatsModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.model_fields" href="#valolyticspy.models.match.PlayerRoundStatsModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.PlayerRoundStatsModel.player" href="#valolyticspy.models.match.PlayerRoundStatsModel.player">player</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.RoundResultModel" href="#valolyticspy.models.match.RoundResultModel">RoundResultModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.RoundResultModel.bombDefuser" href="#valolyticspy.models.match.RoundResultModel.bombDefuser">bombDefuser</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.bombPlanter" href="#valolyticspy.models.match.RoundResultModel.bombPlanter">bombPlanter</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.defusePlayerLocations" href="#valolyticspy.models.match.RoundResultModel.defusePlayerLocations">defusePlayerLocations</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.from_dto" href="#valolyticspy.models.match.RoundResultModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.isBombPlantAfterRoundEnd" href="#valolyticspy.models.match.RoundResultModel.isBombPlantAfterRoundEnd">isBombPlantAfterRoundEnd</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.kills" href="#valolyticspy.models.match.RoundResultModel.kills">kills</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.model_computed_fields" href="#valolyticspy.models.match.RoundResultModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.model_config" href="#valolyticspy.models.match.RoundResultModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.model_fields" href="#valolyticspy.models.match.RoundResultModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.plantPlayerLocations" href="#valolyticspy.models.match.RoundResultModel.plantPlayerLocations">plantPlayerLocations</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.playerStats" href="#valolyticspy.models.match.RoundResultModel.playerStats">playerStats</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.roundCeremony" href="#valolyticspy.models.match.RoundResultModel.roundCeremony">roundCeremony</a></code></li>
<li><code><a title="valolyticspy.models.match.RoundResultModel.winningTeam" href="#valolyticspy.models.match.RoundResultModel.winningTeam">winningTeam</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.Side" href="#valolyticspy.models.match.Side">Side</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.Side.ATTACK" href="#valolyticspy.models.match.Side.ATTACK">ATTACK</a></code></li>
<li><code><a title="valolyticspy.models.match.Side.DEFENSE" href="#valolyticspy.models.match.Side.DEFENSE">DEFENSE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.TeamId" href="#valolyticspy.models.match.TeamId">TeamId</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.TeamId.BLUE" href="#valolyticspy.models.match.TeamId.BLUE">BLUE</a></code></li>
<li><code><a title="valolyticspy.models.match.TeamId.RED" href="#valolyticspy.models.match.TeamId.RED">RED</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="valolyticspy.models.match.TeamModel" href="#valolyticspy.models.match.TeamModel">TeamModel</a></code></h4>
<ul class="">
<li><code><a title="valolyticspy.models.match.TeamModel.from_dto" href="#valolyticspy.models.match.TeamModel.from_dto">from_dto</a></code></li>
<li><code><a title="valolyticspy.models.match.TeamModel.model_computed_fields" href="#valolyticspy.models.match.TeamModel.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.TeamModel.model_config" href="#valolyticspy.models.match.TeamModel.model_config">model_config</a></code></li>
<li><code><a title="valolyticspy.models.match.TeamModel.model_fields" href="#valolyticspy.models.match.TeamModel.model_fields">model_fields</a></code></li>
<li><code><a title="valolyticspy.models.match.TeamModel.side" href="#valolyticspy.models.match.TeamModel.side">side</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>